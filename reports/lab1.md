# chapter3练习

## 编程作业
### 获取任务信息

在任务控制块中添加相关数据字段和计数方法。

## 简答作业

1. 正确进入 U 态后，程序的特征还应有：使用 S 态特权指令，访问 S 态寄存器后会报错。 请同学们可以自行测试这些内容（运行 [三个 bad 测例 (ch2b_bad_*.rs)](https://github.com/LearningOS/rCore-Tutorial-Test-2024S/tree/master/src/bin) ）， 描述程序出错行为，同时注意注明你使用的 sbi 及其版本。
    
2. 深入理解 [trap.S](https://github.com/LearningOS/rCore-Tutorial-Code-2024S/blob/ch3/os/src/trap/trap.S) 中两个函数 `__alltraps` 和 `__restore` 的作用，并回答如下问题:
    
    1. L40：刚进入 `__restore` 时，`a0` 代表了什么值。请指出 `__restore` 的两种使用情景。
    
	    1. 在 `__restore` 函数中，`a0` 是一个参数，它指向用户空间中的 `TrapContext` 结构。`TrapContext` 结构保存了进程在被中断时的所有寄存器的值。当操作系统需要恢复一个被中断的进程时，它会调用 `__restore` 函数，并将 `TrapContext` 的地址传递给 `a0`。

		`__restore` 函数有两种使用情景：
		
		1. **进程切换**：当操作系统需要切换到另一个进程时，它会保存当前进程的所有寄存器值到 `TrapContext`，然后调用 `__restore` 函数来恢复新进程的寄存器值。在这种情况下，`a0` 指向新进程的 `TrapContext`。
		    
		2. **中断处理**：当一个进程被中断（例如，由于硬件中断或系统调用）时，操作系统会保存进程的所有寄存器值到 `TrapContext`，然后处理中断。处理完中断后，操作系统会调用 `__restore` 函数来恢复被中断的进程的寄存器值。在这种情况下，`a0` 指向被中断的进程的 `TrapContext`。
		    
		
		在这两种情况下，`__restore` 函数的作用都是恢复进程的寄存器值，以便进程可以从被中断的地方继续执行。
        
    2. L43-L48：这几行汇编代码特殊处理了哪些寄存器？这些寄存器的的值对于进入用户态有何意义？请分别解释。
        
        ld t0, 32*8(sp)
        ld t1, 33*8(sp)
        ld t2, 2*8(sp)
        csrw sstatus, t0
        csrw sepc, t1
        csrw sscratch, t2
		
		1. `t0`寄存器：这行代码`ld t0, 32*8(sp)`从栈中加载`sstatus`的值到`t0`寄存器。`sstatus`寄存器保存了进程的状态，包括全局中断使能、用户模式中断使能等。在进入用户态时，需要恢复这个值。
		    
		2. `t1`寄存器：这行代码`ld t1, 33*8(sp)`从栈中加载`sepc`的值到`t1`寄存器。`sepc`寄存器保存了被中断的指令的地址。在进入用户态时，需要恢复这个值，以便进程可以从被中断的地方继续执行。
		    
		3. `t2`寄存器：这行代码`ld t2, 2*8(sp)`从栈中加载用户栈的地址到`t2`寄存器。在进入用户态时，需要将这个地址写入`sscratch`寄存器，以便在下一次中断时可以保存用户栈的地址。
		    
		4. `sstatus`系统寄存器：这行代码`csrw sstatus, t0`将`t0`寄存器的值写入`sstatus`寄存器。这样就恢复了进程的状态。
		    
		5. `sepc`系统寄存器：这行代码`csrw sepc, t1`将`t1`寄存器的值写入`sepc`寄存器。这样就设置了下一条要执行的指令的地址。
		    
		6. `sscratch`系统寄存器：这行代码`csrw sscratch, t2`将`t2`寄存器的值写入`sscratch`寄存器。这样就保存了用户栈的地址，以便在下一次中断时可以使用。
		    
		
		这些寄存器的值对于进入用户态非常重要，因为它们决定了进程的状态、下一条要执行的指令的地址，以及用户栈的地址。
        
    3. L50-L56：为何跳过了 `x2` 和 `x4`？
        
        ld x1, 1*8(sp)
        ld x3, 3*8(sp)
        .set n, 5
        .rept 27
           LOAD_GP %n
           .set n, n+1
        .endr

		1. `x2`（也称为`sp`）是栈指针寄存器。在这个上下文中，`sp`寄存器的值已经被改变，因为它现在指向用户空间中的`TrapContext`。如果在这个时候恢复`sp`寄存器的值，那么`TrapContext`的地址就会丢失，无法继续恢复其他寄存器的值。因此，需要在恢复所有其他寄存器的值之后，再恢复`sp`寄存器的值。
		    
		2. `x4`（也称为`tp`）是线程指针寄存器。在RISC-V架构中，`tp`寄存器通常用于存储线程局部存储（Thread Local Storage，TLS）的地址。然而，这个寄存器的值通常由运行时系统（例如，C库）管理，而不是由用户程序直接使用。因此，操作系统在保存和恢复寄存器的值时，通常会跳过`tp`寄存器。
        
    4. L60：该指令之后，`sp` 和 `sscratch` 中的值分别有什么意义？
        
        csrrw sp, sscratch, sp
		
		这条指令的含义是：将 `sscratch` 寄存器的值写入 `sp` 寄存器，并将原来 `sp` 寄存器的值写入 `sscratch` 寄存器。换句话说，这条指令交换了 `sp` 和 `sscratch` 寄存器的值。
		
		在这个上下文中，`sp` 寄存器原来保存的是内核栈的地址，`sscratch` 寄存器保存的是用户栈的地址。执行这条指令后，`sp` 寄存器保存的是用户栈的地址，`sscratch` 寄存器保存的是内核栈的地址。
		
		这样做的目的是为了在处理中断时，能够在用户栈上保存进程的状态。这是因为在中断发生时，进程可能正在用户态运行，此时 `sp` 寄存器保存的是用户栈的地址。为了在用户栈上保存进程的状态，需要将 `sp` 寄存器的值和 `sscratch` 寄存器的值进行交换。
        
    5. `__restore`：中发生状态切换在哪一条指令？为何该指令执行之后会进入用户态？

		在 `__restore` 函数中，状态切换发生在 `sret` 指令。`sret` 是 RISC-V 汇编中的一条指令，全称是 Supervisor Return，用于从特权级别返回。
		
		`sret` 指令的作用是从特权模式（例如，内核模式）返回到用户模式。它会从 `sepc` 寄存器中读取返回地址，并将 `sstatus` 寄存器中的 SPP 位清零，以切换到用户模式。同时，它还会将 `sstatus` 寄存器中的 SPIE 位复制到 SIE 位，以恢复中断使能状态。
		
		在这个上下文中，`sret` 指令执行后，处理器会进入用户态，开始执行用户程序。这是因为在执行 `sret` 指令之前，已经通过 `csrw sstatus, t0` 和 `csrw sepc, t1` 指令恢复了 `sstatus` 和 `sepc` 寄存器的值。这两个寄存器的值是在进程被中断时保存的，因此，恢复这两个寄存器的值后，处理器就可以返回到被中断的地方，继续执行用户程序。
        
    6. L13：该指令之后，`sp` 和 `sscratch` 中的值分别有什么意义？
        
        csrrw sp, sscratch, sp
		
		这条指令的含义是：将 `sscratch` 寄存器的值写入 `sp` 寄存器，并将原来 `sp` 寄存器的值写入 `sscratch` 寄存器。换句话说，这条指令交换了 `sp` 和 `sscratch` 寄存器的值。
		
		在这个上下文中，`sp` 寄存器原来保存的是内核栈的地址，`sscratch` 寄存器保存的是用户栈的地址。执行这条指令后，`sp` 寄存器保存的是用户栈的地址，`sscratch` 寄存器保存的是内核栈的地址。
		
		这样做的目的是为了在处理中断时，能够在用户栈上保存进程的状态。这是因为在中断发生时，进程可能正在用户态运行，此时 `sp` 寄存器保存的是用户栈的地址。为了在用户栈上保存进程的状态，需要将 `sp` 寄存器的值和 `sscratch` 寄存器的值进行交换。
        
    7. 从 U 态进入 S 态是哪一条指令发生的？

		在这段代码中，从用户态（U态）切换到监督态（S态）的操作发生在以下这条指令：
		
		csrw satp, t0
		
		这条指令将`t0`寄存器的值写入`satp`寄存器。`satp`寄存器是RISC-V架构中的页表寄存器，它控制了内存的虚拟到物理的映射。在这个上下文中，`t0`寄存器保存的是内核的页表地址。
		
		写入`satp`寄存器后，接下来的指令：
		
		sfence.vma
		
		是一个内存屏障指令，它确保了之前的所有存储操作在这个指令之前完成，同时也使得新的页表立即生效。
		
		因此，执行`csrw satp, t0`和`sfence.vma`这两条指令后，处理器就切换到了内核的地址空间，也就从U切换到了S态。


# 荣誉准则


1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 **以下各位** 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：
    
    
2. 此外，我也参考了 **以下资料** ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：
    

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。