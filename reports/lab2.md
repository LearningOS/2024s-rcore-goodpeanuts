# chapter4练习

## 功能实现

### 重写 `sys_get_time`

结合ch3中的`sys_get_time`实现并且参考实验指导书上的`sys_write`实现方式，使用`translated_byte_buffer`读取内存中的数据，获取指向目标位置的一段连续内存`buffer`。不同于`sys_write`，这里需要将获取的`buffer`作为可变引用同时转换成`TimeVal`类型的指针，然后在unsafe块中解引用指针进行赋值。

### 重写 `sys_task_info`


和上面一样使用`translated_byte_buffer`获取内存中的数据内存中的数据，将指针转成`TaskInfo`类型，然后解引用赋值。

### 实现`sys_mmap`

在进行`sys_mmap`系统调用时，先检查起始地址`_start` 没有按页大小对齐、检查`_port`是否合法，然后将`_port`转换成`MapPermission`类型，调用当前task的方法`task_mmap`进行内存映射。也就是将内存映射在当前`TCB`的`MemorySet`中。

`TaskManager`的`mmap`方法只使用`MemorySet`已有的`insert_framed_area`方法来分配和建立内存映射。

但是注意到`insert_framed_area`的注释中提到原有的方法没有检查地址冲突。否则会把之前的`sys_task_info`测试样例崩掉因此需要实现一个`check_conlict`方法，在`insert_framed_area`的开始调用，当地址冲突时返回-1

在检查内存地址时不能简单地检查开始和结束地址是否存在于当前页表中。


这样会导致`unmap`的一个测试样例不通过。

### 实现`sys_munmap`

在`MemorySet`中实现一个`remove_framed_area`方法。遍历`vec`对象`areas`，检查其中的每块`area`的起始地址是否为要释放的`start_va`。

这个lab的`sys_munmap`测试样例比较简单，没有考虑到释放内存中间的某块区域的情况，释放的都是一整个`area`。因此只需要找到`MemorySet`中`areas`里的起始地址相同的`area`直接`unmap`然后释放掉就好了


## 问答题
  
1. 请列举 SV39 页表页表项的组成，描述其中的标志位有何作用？

	SV39页表项是RISC-V架构中的一种虚拟内存页表格式。一个SV39页表项是一个64位的值，由以下部分组成：
	
	1. **物理页号（PPN）**：这是页表项的主要部分，占据了位[53:10]。它指向物理内存中的一个页。
	    
	2. **保留位**：位[63:54]是保留位，必须设置为0。
	    
	3. **标志位**：位[9:0]是标志位，包括以下几种：
	    
	    - **有效位（V）**：位0，如果设置为1，表示这个页表项是有效的。
	    - **可读位（R）**：位1，如果设置为1，表示这个页可以被读。
	    - **可写位（W）**：位2，如果设置为1，表示这个页可以被写。
	    - **可执行位（X）**：位3，如果设置为1，表示这个页可以被执行。
	    - **用户位（U）**：位4，如果设置为1，表示这个页可以在用户模式下被访问。
	    - **全局位（G）**：位5，如果设置为1，表示这个页在所有地址空间中都是有效的。
	    - **可访问位（A）**：位6，如果设置为1，表示这个页已经被访问过。
	    - **脏位（D）**：位7，如果设置为1，表示这个页已经被写过。
	
	这些标志位用于控制对页的访问。例如，如果一个页表项的可读位和可写位都被设置为1，那么这个页既可以被读，也可以被写。如果一个页表项的有效位被设置为0，那么这个页表项是无效的，对应的页不能被访问。

2. 缺页
    
    缺页指的是进程访问页面时页面不在页表中或在页表中无效的现象，此时 MMU 将会返回一个中断， 告知 os 进程内存访问出了问题。os 选择填补页表并重新执行异常指令或者杀死进程。
    
    - **请问哪些异常可能是缺页导致的？**

		在RISC-V架构中，以下异常可能是由于缺页导致的：
		
		1. **加载页错误（Load Page Fault）**：当一个进程试图读取一个不存在或无效的页面时，会触发这个异常。
		    
		2. **存储页错误（Store Page Fault）**：当一个进程试图写入一个不存在或无效的页面时，会触发这个异常。
		    
		3. **指令页错误（Instruction Page Fault）**：当一个进程试图执行一个不存在或无效的页面中的指令时，会触发这个异常。
		    
    - **发生缺页时，描述相关重要寄存器的值**，上次实验描述过的可以简略。
		当发生缺页异常时，以下寄存器的值是重要的：
		
		1. **stval寄存器**：这个寄存器包含了引发异常的虚拟地址。
		    
		2. **scause寄存器**：这个寄存器包含了异常的原因。对于缺页异常，scause寄存器的值会是Load Page Fault、Store Page Fault或Instruction Page Fault。
		    
		3. **sepc寄存器**：这个寄存器包含了引发异常的指令的地址。操作系统可以使用这个地址来重新执行这个指令，一旦页表被正确填充。
		    
		4. **satp寄存器**：这个寄存器包含了当前的页表的地址。操作系统需要使用这个地址来查找和填充页表。
        
    
    缺页有两个常见的原因，其一是 Lazy 策略，也就是直到内存页面被访问才实际进行页表操作。 比如，一个程序被执行时，进程的代码段理论上需要从磁盘加载到内存。但是 os 并不会马上这样做， 而是会保存 .text 段在磁盘的位置信息，在这些代码第一次被执行时才完成从磁盘的加载操作。
    
    - **这样做有哪些好处？**

		使用Lazy加载策略有几个主要的好处：
		
		1. **提高效率**：程序在运行过程中可能并不会访问到所有的代码或数据，如果一开始就将所有内容加载到内存，可能会浪费大量的时间和资源。Lazy加载策略只在需要时才加载数据，从而提高了效率。
		    
		2. **节省内存**：如果程序并未访问所有的代码或数据，那么一开始就加载所有内容会占用大量的内存空间。Lazy加载策略可以帮助节省内存，因为只有实际需要的数据才会被加载到内存中。
		    
		3. **快速启动**：如果一个程序有大量的代码或数据需要加载，那么在程序启动时一次性加载所有内容会导致启动时间过长。使用Lazy加载策略，程序可以更快地启动，因为只有必要的部分才会被加载。
		    
		4. **简化错误处理**：如果在程序启动时一次性加载所有内容，那么任何一个加载错误都可能导致程序无法启动。使用Lazy加载策略，错误可以在实际发生时被处理，这样可以简化错误处理，并允许程序在某些情况下继续运行。
        
    其实，我们的 mmap 也可以采取 Lazy 策略，比如：一个用户进程先后申请了 10G 的内存空间， 然后用了其中 1M 就直接退出了。按照现在的做法，我们显然亏大了，进行了很多没有意义的页表操作。
    
    - 处理 10G 连续的内存页面，对应的 SV39 页表大致占用多少内存 (估算数量级即可)？

		在RISC-V的SV39页表中，每个页表项占用8字节（64位）。每个页的大小通常为4KB（4096字节）。
		
		首先计算10GB内存中有多少个页面。10GB等于10 * 1024 * 1024 * 1024字节，所以页面的数量为：
		
		10 * 1024 * 1024 * 1024 / 4096 = 2621440
		
		然后计算页表的大小。因为每个页面需要一个页表项，所以页表的大小为：
		
		2621440 * 8 = 20971520字节，约为20MB
		
		所以，处理10GB连续的内存页面，对应的SV39页表大致占用20MB内存。
        
    - 请简单思考如何才能实现 Lazy 策略，缺页时又如何处理？描述合理即可，不需要考虑实现。

		1. **实现Lazy策略**：
		    
		    - 当程序启动时，操作系统只加载必要的代码和数据到内存，例如程序的入口点和一些关键的数据结构。其他的代码和数据在页表中被标记为无效或者根本不在页表中。
		        
		    - 操作系统保存每个未加载页面的位置信息，这些信息可以是磁盘上的文件偏移，也可以是其他的形式。
		        
		    - 当程序运行并尝试访问一个未加载的页面时，MMU会因为页表项无效或者不存在而触发一个缺页异常。
		        
		2. **处理缺页**：
		    
		    - 当操作系统接收到缺页异常时，它首先需要检查异常的原因。如果是因为页面未加载，那么操作系统需要加载这个页面。
		        
		    - 操作系统查找到未加载页面的位置信息，然后从磁盘或其他存储设备读取这个页面的内容。
		        
		    - 操作系统找到一个空闲的内存页面，然后将读取到的内容复制到这个内存页面。
		        
		    - 操作系统更新页表，将新加载的页面标记为有效，并设置正确的物理地址。
		        
		    - 一旦页表被更新，操作系统可以重新执行引发缺页异常的指令。这次，因为页面已经被加载，所以指令应该能够成功执行。
        
    
    缺页的另一个常见原因是 swap 策略，也就是内存页面可能被换到磁盘上了，导致对应页面失效。
    
    - 此时页面失效如何表现在页表项(PTE)上？

		在许多系统中，当内存页面被换出（swapped out）到磁盘时，对应的页表项（PTE）会被标记为无效，并且通常会在某个字段（例如PTE的某些保留位）中存储该页面在磁盘上的位置信息。
		
		- **有效位（Valid bit）**：这个位被设置为0，表示对应的页表项当前不指向一个有效的内存页面。
		    
		- **交换位（Swap bit）或者保留位**：这个位或者字段被设置为1或者包含了页面在磁盘上的位置信息，表示这个页面已经被换出到磁盘。

3. 双页表与单页表
    
    为了防范侧信道攻击，我们的 os 使用了双页表。但是传统的设计一直是单页表的，也就是说， 用户线程和对应的内核线程共用同一张页表，只不过内核对应的地址只允许在内核态访问。 (备注：这里的单/双的说法仅为自创的通俗说法，并无这个名词概念，详情见 [KPTI](https://en.wikipedia.org/wiki/Kernel_page-table_isolation) )
    
    - 在单页表情况下，如何更换页表？

		在单页表设计中，用户线程和对应的内核线程共享同一张页表，但内核地址只能在内核态访问。当需要切换到另一个进程时，操作系统需要更换页表。以下是更换页表的一般步骤：
		
		1. **保存当前页表的状态**：操作系统需要保存当前页表的状态，以便在将来需要时可以恢复。这通常涉及保存当前页表的物理地址以及其他相关的状态信息。
		    
		2. **加载新的页表**：操作系统需要找到新进程的页表，并将其加载到内存管理单元（MMU）。这通常涉及将新页表的物理地址写入到特定的寄存器或内存位置。
		    
		3. **刷新TLB**：当页表更改后，转译后援缓冲器（TLB）中的条目可能会变得无效。操作系统需要刷新TLB以确保它只包含新页表的条目。
		    
		
		在RISC-V架构中，更换页表通常涉及更新`satp`寄存器的值，这个寄存器保存了当前页表的物理地址。然后，操作系统可以使用特定的指令（例如`sfence.vma`）来刷新TLB。
        
    - 单页表情况下，如何控制用户态无法访问内核页面？（tips:看看上一题最后一问）

		在单页表设计中，用户态和内核态共享同一张页表，但是我们需要防止用户态访问内核页面。这可以通过设置页表项（Page Table Entry，PTE）中的权限位来实现。
		
		在RISC-V架构中，每个页表项有几个权限位，包括：
		
		- U（User）：如果设置了这个位，那么用户态可以访问这个页面。否则，只有内核态可以访问。
		
		为了防止用户态访问内核页面，我们可以在页表中为内核页面清除U位。这样，当用户态试图访问这个页面时，硬件会触发一个异常，因为用户态没有权限访问这个页面。
        
    - 单页表有何优势？（回答合理即可）

		单页表设计有几个主要的优势：
		
		1. **简单性**：单页表设计相对简单，易于理解和实现。因为只有一个页表，所以管理和更新页表的逻辑也相对简单。
		    
		2. **内存效率**：单页表只需要存储一份页表，这可以节省内存。在双页表设计中，每个进程都需要有两个页表（一个用户页表和一个内核页表），这可能会消耗更多的内存。
		    
		3. **性能**：在单页表设计中，上下文切换时只需要更换一次页表，而在双页表设计中可能需要更换两次。此外，因为单页表只有一份，所以在内存中的缓存效率可能会更高。
		    
		4. **兼容性**：许多早期的操作系统和硬件都使用单页表设计，所以单页表设计可能有更好的兼容性。
    

	然而，单页表设计也有一些缺点，例如安全性问题。因为用户态和内核态共享同一张页表，所以如果用户态能够找到一种方法绕过权限检查，那么它可能能够访问和修改内核数据。这是为什么许多现代的操作系统和硬件开始使用双页表或者其他的设计来提高安全性。
        
    - 双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表（回答合理即可）？

		在双页表设计中，页表的更换通常发生在以下情况：
		
		1. **进程切换**：当操作系统从一个进程切换到另一个进程时，需要更换用户页表，因为每个进程都有自己的用户地址空间。
		    
		2. **从用户态切换到内核态**：当进程从用户态切换到内核态时（例如，因为系统调用或者中断），需要更换到内核页表。
		    
		3. **从内核态切换到用户态**：当进程从内核态切换回用户态时，需要更换回用户页表。
		    
		我会选择在以下情况更换页表：
		
		1. **进程切换**：和双页表设计一样，当操作系统从一个进程切换到另一个进程时，需要更换页表。
		    
		2. **内核态和用户态切换**：在单页表设计中，内核态和用户态共享同一张页表，所以在内核态和用户态切换时不需要更换页表。但是，可能需要更新页表的某些部分，例如，如果内核态需要访问一些用户态不能访问的内核数据，那么可能需要临时修改页表来允许这种访问。

## 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 **以下各位** 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

    
2. 此外，我也参考了 **以下资料** ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

[rcore 实验二.mp4](https://cloud.tsinghua.edu.cn/d/eec08e3c8f224e27b01d/files/?p=%2Frcore%20%E5%AE%9E%E9%AA%8C%E4%BA%8C.mp4)

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。